from django.conf                import settings
from django.http                import HttpResponse, HttpResponseRedirect
from django.utils               import timezone
from django.core.exceptions     import PermissionDenied

from rest_framework             import viewsets
from rest_framework.decorators  import api_view, permission_classes
from rest_framework.permissions import AllowAny

from common.campfire            import campfire_message
from common.decorators          import api_arg, rest_response_to_django_response, api_check_user_id
from common.model               import get_field_validators
from common.permissions         import IsAdmin
from common.permissions         import Or, ReadOnly, ReadWrite
from common.validators          import ValueInValidator

from optalim.settings           import APP_BASE_URL, PBX_URL

from paybox                     import LEVEL_NAMES
from paybox.controller          import activate_premium,\
                                       disable_premium, send_transaction_email,\
                                       check_payment_success, update_transaction_from_getparams,\
                                       get_user_tariffs, create_subscription
from paybox.models              import Transaction, Subscription
from paybox.serializers         import SubscriptionSerializer

from user_mgr.models            import User

from rest_framework.response    import Response

import os
import hmac
import hashlib
import binascii
import urllib.parse

from optalim.log import logger

# Standard django views (not an API !)

SOURCE_FILE_PATH = os.path.abspath(os.path.dirname(__file__))
NB_TRIAL_DAYS    = -1 # Update 25/05/15 : no more trial period AFTER payment

def auto_update_transaction_decorator(fcn):
    """
    Decorator that retrieves an existing transaction from the "ref" GET parameter.
    If not found, throw a HTTP redirection.

    Update the transaction with the GET parameters.
    WARNING : It doesn't save the transaction, this is only the object that is modified.
    You must call transaction.save()
    """
    def new_fcn(request):
        try:
            transaction = Transaction.objects.get(ref=request.GET['ref'])
        except Transaction.DoesNotExist:
            logger.critical("transaction not found")
            return HttpResponseRedirect("%s/critical_error" % APP_BASE_URL)
        update_transaction_from_getparams(transaction, request.GET, save=False)
        return fcn(request, transaction)
    return new_fcn

@rest_response_to_django_response
@api_arg('subscription_level', int, validators=get_field_validators(Subscription, 'level'))
@api_arg('nb_months', int, validators=[ValueInValidator([1, 3, 12])])
@api_arg('user_id', int)
def pay_via_paybox(request, subscription_level, nb_months, user_id):
    """
    The user has clicked on the "pay" button.
    This calls the PayBox CGI, that returns some redirections mechanisms (to the bank)
    """
    user = User.objects.get(pk=user_id)
    user_prices = get_user_tariffs(user, cents_to_euros=False)
    price = int(user_prices[subscription_level][nb_months]["after_discount"])
    price *= nb_months

    # Creating a new subscription
    subscription = create_subscription(user, subscription_level, nb_months=nb_months,
                                       price=price, trial_days=NB_TRIAL_DAYS)

    # The payment will happen 1 day after the trial period end
    assert NB_TRIAL_DAYS <= 5, "You cannot legally delay payment to more than 6 days"
    payment_delay = max(0, NB_TRIAL_DAYS + 1)
    payment_delay_str = '%#02i' % payment_delay  # In days, two digits
    ip = request.META['HTTP_X_REAL_IP']

    # Part of the reference generated by us
    ref = '%s_%i_%s_%#06d' % (LEVEL_NAMES[subscription_level], nb_months,
                              timezone.now().strftime("%Y%m%d%H%M%S"), user.id)

    # Creating a transaction on this subscription
    Transaction.objects.create(subscription=subscription, ref=ref,
                               price=price, ip=ip, status=Transaction.STATUS_STARTED)

    kargs = {
        'PBX_SITE': settings.PBX_SITE,    # Our paybox site (given by Paybox)
        'PBX_RANG': settings.PBX_RANG,         # Our paybox rank (given by Paybox)
        'PBX_IDENTIFIANT': settings.PBX_IDENTIFIANT,   # E-transaction identifier (given by e-transaction)
        'PBX_TOTAL': str(price),       # Price in cents
        'PBX_DEVISE': '978',      # Euro
        'PBX_CMD': ref,
        'PBX_PORTEUR': user.email,
        'PBX_RETOUR': 'amount:M;ref:R;auto:A;trans:T;payment:P;card:C;idtrans:S;country:Y;error:E;validity:D;ip:I;BIN6:N;digest:H;sign:K',
        'PBX_EFFECTUE': '%s/payment/accepted/' % APP_BASE_URL,
        'PBX_REFUSE': '%s/payment/refused/' % APP_BASE_URL,
        'PBX_ANNULE': '%s/payment/cancelled/' % APP_BASE_URL,
        'PBX_REPONDRE_A': '%s/op-paybox-validation/' % APP_BASE_URL,
        'PBX_LANGUE': 'FRA',
    }

    # if payment_delay <= 0:
    #     del kargs['PBX_DIFF']
    sorted_kargs = sorted(kargs.items(), key=lambda x: x[0])

    args = []
    for karg_name, karg_value in sorted_kargs:
        assert "\"" not in karg_value, "Quotes in the args"
        args.append("%s=%s" % (karg_name, karg_value))

    str_args = "&".join(args)

    str_args_encoded = urllib.parse.urlencode(sorted_kargs)

    bin_key = binascii.unhexlify(settings.PBX_HMAC_KEY)
    hmac_key = hmac.new(bin_key, str_args.encode('utf-8'), hashlib.sha512)

    paybox_url = PBX_URL + "?" + str_args_encoded + "&PBX_HMAC=" + hmac_key.hexdigest()

    return HttpResponseRedirect(paybox_url)

@auto_update_transaction_decorator
def payment_accepted(request, transaction):
    """
    Redirection from the bank, user-side, once the payment is accepted.

    It activates the premium on the user account. If the bank finally refuse the payment,
    it will be deactivated.

    Important note : it may be not called, even if the payment has been done (if the user close his browser).
                     What is done here must be done too when payment is confirmed by the bank
    """
    logger.info("Payment accepted")

    if transaction.status == Transaction.STATUS_STARTED:
        transaction.status = Transaction.STATUS_ACCEPTED
        update_transaction_from_getparams(transaction, request.GET, save=True)

        activate_premium(transaction.subscription)

    # Redirect to successful payment page
    return HttpResponseRedirect("%s/payment_status/accepted" % APP_BASE_URL)

@auto_update_transaction_decorator
def payment_cancelled(request, transaction):
    """
    The payment was cancelled by the user (user-side, redirection from the bank)
    """
    logger.info("Payment cancelled")

    if transaction.status == Transaction.STATUS_STARTED:
        transaction.status = Transaction.STATUS_CANCELLED
        update_transaction_from_getparams(transaction, request.GET, save=True)

    disable_premium(transaction.subscription)

    return HttpResponseRedirect("%s/payment_status/cancelled" % APP_BASE_URL)

@auto_update_transaction_decorator
def payment_refused(request, transaction):
    """
    The payment was refused by the bank (user-side, redirection from the bank)
    """
    logger.info("Payment refused")

    if transaction.status == Transaction.STATUS_STARTED:
        transaction.status = Transaction.STATUS_REFUSED
        update_transaction_from_getparams(transaction, request.GET, save=True)

    disable_premium(transaction.subscription)

    return HttpResponseRedirect("%s/payment_status/refused" % APP_BASE_URL)

@auto_update_transaction_decorator
def payment_error(request, transaction):
    """
    There has been some technical errors during the payment (user-side, redirection from the bank)
    """
    logger.critical("Payment error")

    if transaction.status == Transaction.STATUS_STARTED:
        transaction.status = Transaction.STATUS_ERROR
        update_transaction_from_getparams(transaction, request.GET, save=True)

    disable_premium(transaction.subscription)

    return HttpResponseRedirect("%s/payment_status/error" % APP_BASE_URL)

def payment_validated(request):
    """
    Call by the e-transaction server (not the user) to confirm the payment.
    Status can be refused/error/cancelled/...
    """
    ip = request.META['HTTP_X_REAL_IP']

    # Checking that the IP is authorized
    if ip not in ('195.101.99.76', '195.25.67.22', '194.2.122.158', '195.25.7.166', '194.2.122.190'):
        logger.critical('Unauthorized IP trying to validate a payment : <%s>' % ip)
        return HttpResponse('Error: invalid ip', status=400)

    try:
        transaction = Transaction.objects.get(ref=request.GET['ref'])
    except Transaction.DoesNotExist:
        logger.critical('Payment feedback from the bank is not matching any transaction in the database')
        return HttpResponse('Error : transaction not found in database', status=400)

    transaction.error_code = int(request.GET['error'])
    error_status = check_payment_success(request, transaction)

    update_transaction_from_getparams(transaction, request.GET, save=False, should_be_stable=True)
    transaction.concluded_at = timezone.now()

    if error_status is None:
        activate_premium(transaction.subscription)
        transaction.status = Transaction.STATUS_CONFIRMED
        campfire_message("New payment ! Level %i, nb months %i, %s euros" % (
            transaction.subscription.level,
            transaction.subscription.nb_months,
            float(transaction.subscription.total_amount) / 100))
    else:
        disable_premium(transaction.subscription)
        if transaction.status == Transaction.STATUS_ACCEPTED:
            # Curiously, this transaction was once accepted (or someone tried to hack us?)
            logger.critical("Accepted transaction is finally cancelled")
            transaction.status = Transaction.STATUS_POST_CANCEL
        else:
            transaction.status = error_status


    transaction.save()

    # Send the bill / or the failure message to the user
    send_transaction_email(transaction)

    # Must return an empty content (cf. e-transaction doc)
    return HttpResponse('')

# @api_view(['POST'])
# @django.db.transaction.atomic
# def api_resiliate(request):

#     subscription = request.user.current_subscription
#     if subscription is None:
#         return Response({"error": "there is no active subscription"}, status=400)

#     if not subscription.can_be_resiliated():
#         return Response({"error": "trial date is passed - cannot resiliate"}, status=400)

#     transactions = subscription.transactions.filter(status=Transaction.STATUS_CONFIRMED)
#     if len(transactions) > 1:
#         return Response({"error": "more than 1 successful transactions for a subscription"}, status=400)
#     if len(transactions) == 0:
#         return Response({"error": "cancelling a failed transaction ?"}, status=400)

#     transaction = transactions[0]
#     assert transaction.price == subscription.total_amount, "Hm ? Not a unique payment ?"

#     # Checking existence of transaction on Paybox
#     paybox_result = pps_paybox_call('00011', request.user.id, transaction.price, transaction.ref, transaction.concluded_at)
#     if paybox_result is None:
#         return Response({"status": "error", "details": "Le désabonnement a échoué (1)"}, status=200)

#     # Internal paybox data, required for next query
#     num_trans, num_appel = paybox_result['NUMTRANS'], paybox_result['NUMAPPEL']

#     # Cancelling payment
#     paybox_result = pps_paybox_call('00005', request.user.id, transaction.price, transaction.ref,
#                                     num_trans=num_trans, num_appel=num_appel, call_number=1)
#     if paybox_result is None:
#         return Response({"status": "error", "details": "Le désabonnement a échoué (2)"}, status=200)

#     # Successfull cancelling
#     disable_premium(subscription, bank_failure=False)

#     send_unsubscribed_email(transaction)

#     return Response({"status": "ok", "details": "Désabonnement réussi"}, status=200)

@api_view(['GET'])
@permission_classes((AllowAny, ))
def api_tariffs(request):
    """
    Returns the tariffs for this user
    """
    user = None
    if not request.user.is_anonymous:
        user = request.user
    res = get_user_tariffs(user)

    return Response(res, status=200)

class SubscriptionViewSet(viewsets.ModelViewSet):
    queryset = Subscription.objects.all()
    serializer_class = SubscriptionSerializer
    permission_classes = (ReadWrite("admin", list = False), )

    def destroy(self, request, pk = None):
        # A subscription must never be deleted. Cancel it instead !
        raise PermissionDenied

    def update(self, request, pk = None):
        # Only start_date, trial_period_end, end_date and cancelled can be changed
        subscription = Subscription.objects.get(pk = request.data["id"])
        for key, value in request.data.items():
            if key in ("start_date", "trial_period_end", "end_date", "cancelled"):
                continue
            if key in subscription.__dict__ and str(subscription.__dict__[key]) != str(value):
                raise PermissionDenied
        return super(viewsets.ModelViewSet, self).update(request, pk)

@api_view(['POST'])
@api_check_user_id
def api_activate_free_trial(request, user_id):
    """
    Creates a free Subscription with the number of days of the selected diet
    """
    if request.user.subscriptions.count() > 0:
        return Response({"status": "error", "error": "you have already created some subscriptions"}, 400)

    user_diet = request.user.diet

    if user_diet is None:
        return Response({"status": "error", "error": "you haven't selected any diet"}, 400)

    level = max(1, user_diet.get_min_subscription_level())
    nb_days = user_diet.free_trial_days

    subscription = create_subscription(request.user, level, nb_days=nb_days,
                                       price=0, trial_days=-1)
    activate_premium(subscription)

    return Response({"status": "ok"}, 200)